###### 第一个C语言程序
~~~c
 //包含头文件，standard input output
 #include<stdio.h>
 //主函数，程序的入口，有且仅有一个
 int main() {
     //库函数, print + function
     printf("hello\n");
     //返回0
     return 0;
~~~
###### 基本数据类型
|整型 |浮点型|
|---|---|
|char|float|
|short|double|
|int|long double|
|long||
|long long (c99标准)|
###### 常量
>+ 字面值常量
>+ const 修饰的 *常变量* (具有常属性，本质是个变量)
>+ #define 定义的标识符常量
>+ 枚举常量-enum
~~~c
enum sex{
    male;//0
    female;//1
};
~~~
###### 变量
|变量|定义位置|作用域|生命周期|默认初始值|
|---|---|---|---|---|
|**全局变量**|代码块外部|整个工程|整个程序|0(可使用)|
|**局部变量**|代码块内部|当前代码块|当前代码块|随机数(不可使用)|
*局部变量和全局变量同名时，局部变量优先。==建议：为避免误会，尽量不要使用同名变量==*
###### 字符串
由双引号引起的一串字符。计算字符串长度时 \0 是结束标志，不算作字符串内容。\0 的[ASCII码](https://tool.ip138.com/ascii_code/)值为0。
###### 转义字符
|转义字符|释义|
|---|--|
|\\?|在书写连续多个问号时使用，防止他们被解析成三字母词|
|\\'|用于表示字符常量'|
|\\“|用于表示一个字符串内部的双引号|
|\\\\|用于表示一个反斜杠，防止它被解释为一个转义序列符|
|\\a|警告字符，蜂鸣|
|\\b|退格符|
|\\f|进纸符|
|\\n|换行|
|\\r|回车|
|\\t|水平制表符|
|\\v|垂直制表符|
|\\ddd|ddd表示1~3个8进制数字。eg:\32,即8进制数32对应的10进制数作为ASCII码对应的字符|
|\\xdd|dd表示2个16进制数字。eg:\x30|
###### 标识符(identifier)
>就是变量、函数、类型等的名字，由字母、数字、下划线组成，不能以数字开头。
###### 常见关键字
~~~c
auto break case char const continue default do double else enum
extern float for goto if int long register return short signed
sizeof static struct switch typedef union unsigned void volatile while
~~~
*extern:用来声明变量和函数作为外部变量或者函数供其它文件使用*
*register:寄存器*
*union:联合体*
*volatile:*
*typedef:类型重定义*
```c
typedef unsigned int uint;
unsigned int num1 = 0;
uint num2 = 0;
```
*static:修饰变量和函数*
>static 修饰局部变量(静态局部变量)，延长局部变量的生命周期。
>static 修饰全局变量(静态全局变量)，改变了全局变量的作用域，使静态全局变量只能在本源文件内使用
>ststic 修饰函数(静态函数)，改变了函数的链接属性（外部链接属性消失）
###### #defune 定义常量和宏
```c
//#define定义标识符常量
#define MAX 100
//#define定义宏-带参数
#define MAX(X,Y) (X>Y?X:Y)
```
###### 原码、反码、补码
>整数的二进制表示有原码、反码、补码，==存入到内存里的是补码==
>正整数的 原码\==反码\==补码，负整数的==原码--(符号位不变，其他位按位取反)-->反码--(+1)-->补码==
###### 操作符
>**操作符的属性**
复杂表达式的求值有3个影响因素
1、[操作符的优先级](https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/4752611)
2、操作符的结合性
3、是否控制求值顺序
![操作符优先级表](https://images.cnblogs.com/cnblogs_com/xiehy/C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E6%8F%8F%E8%BF%B0.jpg)

>**算术操作符**
```c
+
-
*
/ 左右两个操作数均为整数，执行整数除法，向0取整；否则执行浮点数除法
% 模,左右两个操作数必须为整数，返回整出之后的余数
```
>**移位操作符**
```c
左移一位即乘以2；右移一位即除以2。对于移位操作符，不可以移动负数位，这是标准未定义的
<< 左移操作符 左边丢弃，右边补0
>> 右移操作符 算术右移，右边丢弃，左边补原符号位；逻辑右移，右边丢弃，左边补0
```
```c
int num =4;
num << -1;//error
```
>**位操作符**
```c
& 按位与 同1为1
| 按位或 同0为0
^ 按位异或 相同为0，相异为1
```
```c
//交换两个整数a和b，不使用临时变量
a = a + b;
b = a - b;
a = a - b;
//a + b有可能会整型溢出，故改进如下：
a = a ^ b;
b = a ^ b;
a = a ^ b;
//BUT，以上两种方法可读性差，执行效率不高，故未来写代码还是建议使用临时变量
```
```c
//求一个整数存储在内存中的二进制数中1的个数
int main(){
    int num = 0;
    int count = 0;
    scanf("%d",&num);
    while(num){
        if(num%2==1){
            count++;
        }
        num/=2;
    }
    printf("二进制中1的个数：%d",count);
    return 0;
}
//这样的实现方式对负数不能做到，故还可优化如下：
int main(){
    int num = 0;
    int count = 0;
    scanf("%d",&num);
    for(int i = 0;i<32;i++){
        if(((num>>i)&1)==1){
            count++;
        }
    }
    printf("二进制中1的个数：%d",count);
    return 0;
}
//这里必须循环32次，故还可优化如下：
int main(){
    int num = 0;
    int count = 0;
    scanf("%d",&num);
    while(num){
        count++;
        num = num & (num-1);
    }
    printf("二进制中1的个数：%d",count);
    return 0;
}
```
```c
//查找单身狗
int arr[] = {1,2,3,4,5,4,3,2,1};
for(int i = 0;i < sizeof(arr)/sizeof(arr[0]);i++){
    int count = 0;
    for(int j = 0;j < sizeof(arr)/sizeof(arr[0]);j++){
        if(arr[i]==arr[j])
            count++;
    }
    if(count == 1){
        printf("%d"arr[i]);
        break;
    }
}
//暴力求解时间复杂度比较大，算法优化如下：
//a^a=0
//0^a=0
int ret = 0;
for(int i = 0;i<sizeof(arr)/sizeof(arr[0]);i++){
    ret = ret ^ arr[i];
}
pritf("%d",ret);
```
>**赋值操作符**
```c
+=
-=
*=
/=
%=
<<=
>>=
&=
|=
^=
```
>**单目运算符**
```c
! 逻辑反
+ 正值
- 负值
& 取地址
sizeof 操作数的类型长度，以字节为单位,返回无符号数
~ 按位取反
++ 自增
-- 自减
* 间接访问(解引用)操作符
(类型) 强制类型转换
```
```c
int a = 10;
int arr[10] = {0};
printf("%d",sizeof(a));
printf("%d",sizeof a);
printf("%d",sizeof(int));//对类型不可以去掉括号
printf("%d",sizof(arr));
printf("%d",sizeof arr);
printf("%d",sizeof(int [10]));//对数组而言，去掉数组名就是类型名
//关于数组传参
void test(int arr[]){//形参用指针接收地址
 printf("%d\n", sizeof(arr));//4 or 8
}
int main(){
    int arr[10] = {0};
    printf("%d\n", sizeof(arr));//40
    test(arr);//数组传参传的是数组首元素的地址
    return 0;
}
//另外，sizeof（）中的表达式不进行真实的运算
short a = 0;
int b = 1;
printf("%d",sizeof(a+=b));//2
printf("%d",a);//0
//关于自增自减运算符，以自增运算符为例：
//前置++，先++，后使用
int a = 1；
printf("%d",++a);//2
//后置++，先使用，后++
int a = 1;
printf("%d",a++);//1
printf("%d",a);//2
```
>**关系操作符**
```c
>
>=
<
<=
==
!=
```
>**逻辑操作符**
```c
&& 逻辑与 //左边如果有假，右边将不再计算
|| 逻辑或 //左边如果有真，右边将不再计算
```
```c
int main(){
    int i = 0, a = 0, b = 2, c = 3, d = 4;
    i = a++ && ++b && d++;
    printf("a=%d,b=%d,c=%d,d=%d",a,b,c,d);//1,2,3,4
    //i = a++ || ++b || d++;
    //printf("a=%d,b=%d,c=%d,d=%d");//1,3,3,4
    return 0;
}
```
>**条件操作符(三目操作符)**
```c
exp1?exp2:exp3 // 懂?懂:不懂
```
>**逗号表达式**
```c
exp1,exp2,exp3,...expN
逗号表达式，就是用逗号隔开的多个表达式。逗号表达式，从左向右依次执行。整个表达式的结果是最后一个表达式的结果。
```
>**other**
```c
[] 下标引用操作符，操作数为数组名和索引值
() 函数调用操作符，操作数为函数名和参数
. 结构体.成员名
-> 结构体指针->成员名
```
---
学习操作符最终还是为了表达式求值，而表达式求值的顺序一部分是由操作符优先级和结合性决定。同样，有些表达式的操作数在求值的过程中可能需要转换为其他类型。
###### 隐式类型转换
>C的整型算术运算总是至少以缺省整型类型的精度来进行的。为了获得这个精度，表达式中的字符型和短整型操作数在使用之前被转换为普通整型，这种转换称为 **==整型提升==**。在K&R和C89的早期实现中，基于short和char的算术运算陷入两难的困境，因为可能会产生两种不同的结果。因此，在C99中很明确地定义了整型提升的规则：==如果int能够表示原始类型中的所有数值，那么这个数值就被转成int型，否则，它被就转成unsigned int型==。这种规则被称为整型提升。所有其它类型都不会被整型提升改变。那么如何进行整型提升呢？==整形提升是按照变量的数据类型的符号位来提升的，无符号补0==。
*整型提升的意义：
表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度一般就是int的字节长度，同时也是CPU的通用寄存器的长度。因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度。通用CPU（general-purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令中可能有这种字节相加指令）。所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算。*
```c
char a = 3;
//3在内存中的补码是00000000 00000000 00000000 00000011
//要把3保存在a里，遗憾的是，a只有1个字节大小，此时会发生截断，会将最低位字节的内容00000011存入a
char b = 127;
//127在内存中的补码是00000000 00000000 00000000 01111111
//同样，截断以后，b中存放的是01111111
char c = a + b;
//a和b的值被提升为普通整型，然后再执行加法运算。加法运算完成之后，结果将被截断，然后再存储于c
//整型提升：
//a----00000000 00000000 00000000 00000011
//b----00000000 00000000 00000000 01111111
//相加=00000000 00000000 00000000 10000010
//同样，c只有1个字节大小，故相加结果截断后10000010存放于c
printf("%d",c);//%d打印一个整型
//整型提升：
//c----11111111 11111111 11111111 10000010(补码)
//c----11111111 11111111 11111111 10000001(反码)
//c----10000000 00000000 00000000 01111110(原码)
//故打印结果是 -126
```
>**算术转换**
如果某个操作符的操作数属于不同的类型，那么除非其中一个操作数转换为另一个操作数的类型，否则操作就无法进行。
>>long double
double
float
unsigned long int
long int unsigned int
int

>如果某个操作数的类型在上面这个列表中排名较低，那么首先要转换为另外一个操作数的类型后执行运算。
###### 分支和循环
C语言中，0表示假，非0表示真
>**分支语句**
```c
if(表达式){
    语句;
}

if(表达式){
    语句;
}else{
    语句;
}

//多分支
if(表达式){
    语句;
}else if(表达式){
    语句;
}else{
    语句;
}
```
```c
//判断一个数是否为奇数，输出1-100之间的的奇数
int i = 1;
while(i<=100){
    printf("%d",i);
    i += 2;
}
while(i<=100){
    if(i%2!=0){
        printf("%d",i);
    }
    i++;
}
```
```c
switch(整型表达式){
    case: 整形常量表达式;
        bredk;
    default:
        break;
}
//switch语句中case表达式不要求顺序
//在switch语句中，我们没法直接实现分支，搭配break使用才能实现真正的分支，break语句的实际效果是把语句列表划分为不同的部分。
//当表达式的值与所有的case标签都不匹配时，default子句后面的语句就会执行。
//每个switch语句中只能出现一条default子句，但它可以出现在语句列表的任何位置，而且语句流会像贯穿一个case标签一样贯穿default子句
```
>**循环语句**
```c
while(表达式){
    循环语句；
}
//当循环中遇到break，就会永久终止循环
//当循环中遇到continue，终止本次循环，直接跳到下一次循环的入口判断
char password[20] = {0};
scanf("%s",passward);
while(getchar()!='\n'){
    ;//干掉输入的空白符
}
ret = getchar();//Y or N
```
>>当输入函数需要读入数据时，会检测输入缓冲区（想象它是一个字符数组），如果缓冲区是空的，它就会停下等待你从键盘输入。
由于*scanf是读数据直到看见空白符（空白符：指空格符、制表符、回车符）就停止的输入函数。*
假如你从键盘中键入123456\n，scanf就会将123456读走，只留下\n在输入缓冲区。
特别的是，当空白符出现在缓冲区的开头，scanf会忽略先导的空白符。但是，当参数是%c,scanf就会把缓冲区的第一个字符读走，不论它是什么。
这里提一下get()这个函数，它不管是什么一律读进来，直到遇到回车符才停下。
```c
for(初始化;条件判断;调整){
    循环语句;
}
//不可在for 循环体内修改循环变量，防止 for 循环失去控制。
//建议for语句的循环控制变量的取值采用“前闭后开区间”写法。
```
```c
do{
    循环语句;    
}while(表达式);
```
```c
//test
//1、计算n的阶乘
int result = 1;
for(int i = 1; i<=n; i++){
    result *= i; 
}
//2、计算1！+2！+ … +10！
int sum = 0;
for(int i = 1; i<=10;i++){
    int result = 1;
    for(int j = 1; j<=i; j++){
        result *= j;
    }
    sum += result;
}
//算法优化：
int sum = 0;
int result = 1;
for(int i = 1; i<=10;i++){
    result *= i;
    sum += result;
}
//3、在一个有序数组中查找具体的某个数字n。
int arr[] = {1,2,3,4,5,6,7,8,9,10};
int find = 7;假设查找7这个元素
int sz = sizeof(arr)/sizeof(arr[0]);//计算元素个数
for(i = 0; i<sz; i++){
    if(find == arr[i]){
        //找到...
        break；
    }
}
if(i == sz){
    //找不到...
}
//算法优化：
int arr[] = {1,2,3,4,5,6,7,8,9,10};
int find = 7;
int sz = sizeof(arr)/sizeof(arr[0]);
int left = 0;//左元素下标
int right = sz - 1;//右元素下标
while(left <= right){
int mid = (left + right)/2;//中间元素下标
if(arr[mid] > k){
    right = mid -1;
}else if(arr[mid] < k){
    left = mid + 1;
}else{
    //找到...
}
}
if(left>right){
    //找不到...
}
//如何实现一个二分查找函数：
int bin_search(int arr[], int left, int right, int key){
 int mid = 0;
 while(left<=right){
    mid = (left+right)>>1;
    if(arr[mid]>key){
        right = mid-1;
     }else if(arr[mid] < key){
        left = mid+1;
    }else
        return mid;//找到了，返回下标
 }
 return -1;//找不到
}
//4、编写代码，演示多个字符从两端移动，向中间汇聚
char arr1[] = "hello world";
char arr2[] = "###########";
//注意：char arr[]="abc";这种写法在arr中实际存的是'a','b','c','\0'
//此时如何获取最后一个元素的下标
//arr/arr[0] - 2; or strlen(arr) - 1;
int left = 0;
int right = strlen(arr1) - 1;
while(left<=right){
    printf("%s\n",arr2);
    arr2[left]=arr1[left];
    arr2[right]=arr1[right];
    left++;
    right--;
    system("cls");
    Sleep(1000);
    printf("%s\n",arr2);
}
//for循环实现
for(left=0, right=strlen(arr1)-1;
     left <= right;
     left++, right--){
    Sleep(1000);
    arr2[left] = arr1[left];
    arr2[right] = arr1[right];
    printf( "%s\n", arr2);
   }
//5、求两个数m和n的最大公约数（辗转相除法）
while(tmp=m%n){
    m=n;
    n=tmp;    
}
printf("%d",n0);//最大公约数
```
###### 函数
>==库函数，== 查文档
[cplusplus](www.cplusplus.com)
[cppreference](http://en.cppreference.com)

>==自定义函数==
ret_type fun_name( paral ){
statement;//语句项
}
ret_type 返回类型
fun_name 函数名
paral    函数参数
==实际参数（实参）==
*真实传给函数的参数，叫实参。实参可以是：常量、变量、表达式、函数等。无论实参是何种类型的量，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参。*
==形式参数（形参）==
*形式参数是指函数名后括号中的变量，因为形式参数只有在函数被调用的过程中才实例化（分配内存单元），所以叫形式参数。形式参数当函数调用完成之后就自动销毁了。因此形式参数只在函数中有效。*
函数调用时，形参拥有自己的空间，同时拥有和实参一模一样的内容，所以我们认为：
==形参实例化之后其实相当于实参的一份临时拷贝。==
```c
//写函数交换两个数的值
void Swap(int* pa,int* pb){//形参
    int tmp = 0;
    tmp = *pa;
    *pa = *pb;
    *pb = tmp;
}
int a = 10;
int b = 20;
Swap(&a,&b);//实参
```
>**函数的调用**
==传值调用== 函数的形参和实参分别占有不同内存块，对形参的修改不会影响实参。
==传址调用== 传址调用是把函数外部创建变量的内存地址传递给函数参数的一种调用函数的方式。这种传参方式可以让函数和函数外边的变量建立起正真的联系，也就是函数内部可以直接操作函数外部的变量。
```c
//编写int binsearch(int x, int v[], int n); 功能：在v[0]<=v[1]<=v[2]<=…<=v[n-1]的数组中查找x,返回下标
int binsearch(int x,int v[],int n){
    int left = 0;
    int right n -1;
    while(left<=right){
        int mid = (left+right)/2;
        if(v[mid]<x){
            left = mid +1;
        }else if(v[mid]>x){
            right = mid -1;
        }else{
            return mid;
        }
    }
    return -1;
}
int arr[]={1,2,3,4,5,6,7,8,9,10};
int sz = size0f(arr)/sizeof(arr[0]);
binsearch(7,arr,sz);
//数组传参，其实传的是数组第一个元素的地址，本质上形参是用指针接收这个数组名
//故不在函数内求数组元素个数sizeof(指针)是4 or 8
```
>>**函数的嵌套和链式访问**
函数的嵌套就是在一个函数里调用其他函数。
函数的链式访问就是把一个函数的返回值作为另外一个函数的参数。
```c
printf("%d", printf("%d", printf("%d", 43)));
//输出的是4321，printf函数的返回值是输出的字符数量，包括数字、字母、标点符号、空格等。
```
>**函数递归**
程序调用自身的编程技巧称为递归（ recursion）。递归做为一种算法在程序设计语言中广泛应用。一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的主要思考方式在于：把大事化小
>>==递归的两个必要条件==
存在限制条件，当满足这个限制条件的时候，递归便不再继续。
每次递归调用之后越来越接近这个限制条件。
```c
//stcak overflow栈溢出，递归常见的错误。
int main(){
    printf("hello");
    main();
}
//一个整型值（无符号），按照顺序打印它的每一位。例如1234 输出1 2 3 4
void print(int n){
    if(n>9){
        print(n/10);
    }
    printf("%d",n%10);
}
print(1234);
//编写函数不允许创建临时变量，求字符串的长度。
int mystrlen(char* str){
    if(*str != '\0')
        return 1+mystrlen(str+1);
    return 0;
}
char arr[]="hello";
int len = mystrlen(arr);
```
>递归与迭代
>+ 许多问题是以递归的形式进行解释的，这只是因为它比非递归的形式更为清晰。
>+ 但是这些问题的迭代实现往往比递归实现效率更高，虽然代码的可读性稍微差些。
>+ 当一个问题相当复杂，难以用迭代实现时，此时递归实现的简洁性便可以补偿它所带来的运行时开销。
```c
//求n的阶乘
int factorial(int n){//递归
    if(n <= 1)
        return 1;
    return n * factorial(n-1);
}
int factorial(int n){//非递归
    int result = 1;
    while(n>1){
        result*=n;
        n--;
    }
    return result;
}
//斐波那契数列
int fib(int n){//递归
    if (n <= 2)        
        return 1;
    return fib(n - 1) + fib(n - 2);
}
int fib(int n){//非递归
    int result = 0;
    int result1 = 0;
    int result2 = 0;
    result = result1 = 1;
    while(n>2){
        n--;
        result2 = result1;
        result1 = result;
        result = result2 + result1;
     }
    return result;
}
//汉诺塔
//青蛙跳台阶...
```
###### 数组
相同类型元素的集合。
>一维数组的创建和初始化
```c
数组的元素类型  数组名[常量表达式]
//[]中的常量表达式用来表示数组的大小，创建数组，[]中要给一个常量才可以，不能使用变量。
数组的初始化，在创建数组的同时给数组的内容一些合理初始值（初始化）。
//不完全初始化，剩下的元素默认初始化为0
int arr1[5]={1,2,3};//arr1中存放的其实是1，2，3，0，0
char arr2[5]={'a','b','c'};//arr2中存放的其实是a,b,c,0,0
char arr3[5]="abc";//arr3中存放的其实是a,b,c,0,0;第一个0是\0的ASCII码
数组在创建的时候如果想不指定数组的确定的大小就得初始化。数组的元素个数根据初始化的内容来确定。
char arr4[]={'a','b','c'};//数组元素个数其实是3
char arr5[]="abc";//数组元素个数其实是4，还有一个\0
strlen(arr4);//随机数，从数组的首地址开始，知道遇到\0结束
strlen(arr5);//3，只计算\0之前的字符
sizeof(arr4);//3
sizeof(arr5);//4
```
>一维数组的使用
>>数组是使用下标来访问的，下标是从0开始。数组的大小可以通过计算得到。
sizeof(arr)/sizeof(arr[0]);

>一维数组在内存中的存储
>>数组在内存中是连续存放的，随着数组下标的增长，元素的地址，也在有规律的递增，

>二维数组的创建
```c
int arr[3][4] = {0};//3行4列
```
>二维数组的初始化
```c
int arr[2][3] = {1,2,3,4};//其实第一行存的是1,2,3,第二行存的是4,0,0
int arr[2][3] = {{1,2},{3,4}};//其实第一行存的是1,2,0,第二行存的是3,4,0
int arr[][3] = {{1,2},{3,4}};//第一行1,2,0,第二行3,4,0
//在二维数组的创建初始化中，只有"行"是可以省路的
```
>二维数组在内存中的存储
>>同一维数组一样，二维数组在内存中也是连续存放的。二维数组的本质也是一维数组，只不过每个数组元素又是一个数组
```c
//冒泡排序函数
void bubblesort(char arr[],int sz){
    for(int i = 0;i<sz-1;i++){
        int flag = 1;
        for(int j = 0;j<sz-i-1;j++){
            if(arr[j]>arr[j+1]){
                int tmp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = tmp;
                flag = 0;//排除正好升序情况退出函数
            }
        }
        if(flag == 1){
            break;
        }
    }
}
int arr[10] = {10,9,8,7,6,4,5,3,2,1};
int sz = sizeof(arr)/sizeof(arr[0]);
bubblesort(arr,sz);
```
>**数组作为参数**
数组名就是数组首元素的地址，但以下两种情况除外：
1、sizeof(数组名)，计算整个数组的大小。sizeof内部单独放一个数组名，数组名表示整个数组。
2、&(数组名)，取出的是数组的地址。&(数组名)，数组名表示整个数组。
```c
int arr[]={1,2,3};
printf("%p",arr);//首元素地址
printf("%p",&arr[0]);//首元素地址
printf("%p",&arr);//整个数组的地址
```
###### 指针（pointer）
==内存:== 我们可以把计算机的内存看作是一条长街上的一排房子，每个房子的大小为1byte。为了能够有效的访问到内存的每个单元，就给内存进行编号，这些编号被称为==内存单元的地址==（地址是唯一标识一块地空间的）。存放地址的变量称为指针变量，而指针里又存的是地址，所以我们经常称指针就是地址。（存放在指针中的值都被当成地址处理）
>世界上只有10种人，一种懂二进制，一种不懂
>>bit--最小的存储单位
>>byte--最常用的存储单位
>>1byte = 8it
>>1kb = 1024byte
>>1mb = 1024kb
>>1gb = 1024mb
>>1tb = 1024gb
>>1pb = 1024tb
>>>一个内存单元的大小是多大？在32位机器上，地址是32个0或1组成的二进制序列，而一个字节占8个比特位，所以指针的大小是4个字节。同理，64位机器上，指针的大小是8个字节。
```c
int num = 0;
//打印16进制地址
printf("%p",&num);
//指针变量用来存放地址
int* p = &num;
printf("%p",p);
//解引用操作符 * ，找到指针p所指的对象
*p = 1;//*p其实就是num
printf("%d",num);//1
```
>**指针和指针类型**
指针的定义方式是：==type + *==，char*类型的指针是为了存放char类型变量的地址，int*类型的指针是为了存放int类型变量的地址。
>>指针的类型决定了**指针+-整数**向前或者向后一步的步长（距离）。
```c
int num = 0;
char* p1 = &num;
int* p2 = &num;
printf("%p",&num);//输出num的地址
printf("%p",p1+1);//在num地址上＋char大小字节
printf("%p",p2+1);//在num地址上＋int大小字节
```
>>指针的类型决定了对**指针解引用**的时候有多大的访问权限（能操作几个字节）
```c
int num = 0x11223344;//两个16进制数是1个字节
char* p1 = &num;
int* p2 = &num;
p1 = 0;//num开始的地址对应内存中存的数变为了00223344
p2 = 0;//num开始的地址对应内存中存的数变为了00000000
```
>**野指针**
指针指向的位置是不可知的（随机的，不正确的，没有明确限制的）
>>指针未初始化造成的野指针
```c
int* p;//局部变量指针未初始化，默认随机值
p = 10;//非法访问内存
```
>>指针越界访问造成的野指针
```c
int arr[10]={0};
int* p=arr;
for(int i = 0;i<12;i++){
    *(p++)=i;//当指针指向的地址超出数组的范围时，p就是野指针
    //以上代码等效于：
    //*p=i;
    //p++;
}
```
>>指针指向的空间释放造成的野指针
```c
int* test(){
    int num = 0;//局部变量
    return &num;
}
int main(){
    int* p = test();//P指向的地址被释放
    printf("%p",p);
}
```
>>>==如何规避野指针==
指针要初始化，即使是置NULL,指针释放也要及时置NULL，小心指针越界，使用指针前检查有效性：
if(pointer!=NULL)  {...}

>**指针运算**

>>指针-指针：表示中间元素的个数
```c
int arr[10]={0};
printf("%d",&arr[9]-&arr[0]);//9
printf("%d",&arr[0]-&arr[9]);//-9
```
>指针的关系运算（比较大小）
```c
#define N 5
int arr[N];
int* p;
for(p=&arr[0];p<arr[N];){
    *p++ = 0;
}
for(p=&arr[N];p>&arr[0];){
    *--p = 0;
}
for(p=&arr[N-1];p>=&arr[0];p--){
    *p = 0;
}
```
>>C语言标准规定：允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与指向第一个元素之前的那个内存位置的指针进行比较。

>**指针和数组**
绝大多数情况下，数组名表示数组首元素的地址，
int arr[10]=0;
int* p =arr;
==&arr[i]<\==>p+i==,p+i其实就是计算数组下标位i的地址,*(p+i)就对应arr[i]

>**二级指针**
```c
int num = 10;
int* p = &num;
int** pp = &p;//pp就是一个二级指针
**pp = 20;//等价于num=20
```
>**指针数组**
指针数组本质是存放指针的数组，而数组指针本质是指针。
###### 结构体
结构体是一些不同类型的成员变量的集合。

函数的声明和定义